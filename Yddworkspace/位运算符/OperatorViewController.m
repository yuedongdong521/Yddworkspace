//
//  OperatorViewController.m
//  Yddworkspace
//
//  Created by ispeak on 2018/1/12.
//  Copyright © 2018年 QH. All rights reserved.
//
/*
位运算

位运算的运算分量只能是整型或字符型数据，位运算把运算对象看作是由二进位组成的位串信息，按位完成指定的运算，得到位串信息的结果。

位运算符有：

&(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。
其中，按位取反运算符是单目运算符，其余均为双目运算符。
位运算符的优先级从高到低，依次为~、&、^、|，
其中~的结合方向自右至左，且优先级高于算术运算符，其余运算符的结合方向都是自左至右，且优先级低于关系运算符。

(1)按位与运算符(&)

按位与运算将两个运算分量的对应位按位遵照以下规则进行计算：
0 & 0 = 0, 0 & 1 = 0, 1 & 0 = 0, 1 & 1 = 1。
即同为 1 的位，结果为 1，否则结果为 0。
例如，设3的内部表示为
00000011
5的内部表示为
00000101
则3&5的结果为
00000001
按位与运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x & 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x & 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。

(2)按位或运算符(|)

按位或运算将两个运算分量的对应位按位遵照以下规则进行计算：
0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1
即只要有1个是1的位，结果为1，否则为0。
例如，023 | 035 结果为037。
按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成：
j = 017|j

(3)按位异或运算符(^)

按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算：
0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0
即相应位的值相同的，结果为 0，不相同的结果为 1。
例如，013^035结果为026。
异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量j的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，结果是0,原来为0的位，结果是1。

(4)按位取反运算符(~)

按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。例如, ~7的结果为0xfff8。

取反运算常用来生成与系统实现无关的常数。如要将变量x最低6位置成0，其余位不变，可用代码x = x & ~077实现。以上代码与整数x用2个字节还是用4个字节实现无关。

当两个长度不同的数据进行位运算时(例如long型数据与int型数据)，将两个运算分量的右端对齐进行位运算。如果短的数为正数，高位用0补满；如果短的数为负数，高位用1补满。如果短的为无符号整数，则高位总是用0补满。

位运算用来对位串信息进行运算，得到位串信息结果。如以下代码能取下整型变量k的位串信息的最右边为1的信息位：((k-1)^k) & k。

移位运算

移位运算用来将整型或字符型数据作为二进位信息串作整体移动。有两个运算符：
<< (左移) 和 >> (右移)
移位运算是双目运算，有两个运算分量,左分量为移位数据对象，右分量的值为移位位数。移位运算将左运算分量视作由二进位组成的位串信息,对其作向左或向右移位，得到新的位串信息。
移位运算符的优先级低于算术运算符，高于关系运算符，它们的结合方向是自左至右。
(1)左移运算符(<<)
左移运算将一个位串信息向左移指定的位，右端空出的位用0补充。例如014<<2,结果为060,即48。
左移时，空出的右端用0补充，左端移出的位的信息就被丢弃。在二进制数运算中，在信息没有因移动而丢失的情况下，每左移1位相当于乘2。如4 << 2，结果为16。
(2)右移运算符(>>)
右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12>>2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2。在右移时，需要注意符号位问题。对无符号数据，右移时，左端空出的位用0补充。对于带符号的数据，如果移位前符号位为0(正数)，则左端也是用0补充；如果移位前符号位为1(负数)，则左端用0或用1补充，取决于计算机系统。对于负数右移，称用0 补充的系统为“逻辑右移”，用1补充的系统为“算术右移”。以下代码能说明读者上机的系统所采用的右移方法：
printf("%d\n\n\n", -2>>4);
若输出结果为-1，是采用算术右移；输出结果为一个大整数，则为逻辑右移。
移位运算与位运算结合能实现许多与位串运算有关的复杂计算。设变量的位自右至左顺序编号，自0位至15位，有关指定位的表达式是不超过15的正整数。以下各代码分别有它们右边注释所示的意义：
~（~0 << n）
(x >> (1 p-n)) & ~(~0 << n)
new |= ((old >> row) & 1) << (15 – k)
s &= ~(1 << j)
for(j = 0; ((1 << j) & s) == 0; j ) ;
===================================================================================================
位运算是指按二进制进行的运算。在系统软件中，常常需要处理二进制位的问题。C语言提供了6个位操作运算符。这些运算符只能用于整型操作数，即只能用于带符号或无符号的char,short,int与long类型。
C语言提供的位运算符列表：

运算符 含义 描述
& 按位与 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
| 按位或 两个相应的二进制位中只要有一个为1，该位的结果值为1
^ 按位异或 若参加运算的两个二进制位值相同则为0，否则为1
~ 取反 ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1变0
<< 左移用来将一个数的各二进制位全部左移N位，右补0
>> 右移将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数，高位补0
1、“按位与”运算符（&）
按位与是指：参加运算的两个数据，按二进制位进行“与”运算。如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。这里的1可以理解为逻辑中的true,0可以理解为逻辑中的false。按位与其实与逻辑上“与”的运算规则一致。逻辑上的“与”，要求运算数全真，结果才为真。若，A=true,B=true,则A∩B=true 例如：3&5 3的二进制编码是11(2)。（为了区分十进制和其他进制，本文规定，凡是非十进制的数据均在数据后面加上括号，括号中注明其进制，二进制则标记为2）内存储存数据的基本单位是字节（Byte），一个字节由8个位（bit)所组成。位是用以描述电脑数据量的最小单位。二进制系统中，每个0或1就是一个位。将11（2）补足成一个字节，则是00000011（2）。5的二进制编码是101（2），将其补足成一个字节，则是00000101（2）
按位与运算：
00000011(2)
&00000101(2)
00000001(2)
由此可知3&5=1
c语言代码：
#include <stdio.h>
main()
{
    int a=3;
    int b = 5;
    printf("%d",a&b);
}
按位与的用途：
（1）清零
若想对一个存储单元清零，即使其全部二进制位为0，只要找一个二进制数，其中各个位符合一下条件：
原来的数中为1的位，新数中相应位为0。然后使二者进行&运算，即可达到清零目的。
例：原数为43，即00101011（2），另找一个数，设它为148，即10010100（2），将两者按位与运算：
00101011（2）
&10010100（2）
00000000（2）
c语言源代码：
#include <stdio.h>
main()
{
    int a=43;
    int b = 148;
    printf("%d",a&b);
}
（2）取一个数中某些指定位
若有一个整数a(2byte),想要取其中的低字节，只需要将a与8个1按位与即可。
a 00101100 10101100
b 00000000 11111111
c 00000000 10101100
（3）保留指定位：
与一个数进行“按位与”运算，此数在该位取1.
例如：有一数84，即01010100（2），想把其中从左边算起的第3，4，5，7，8位保留下来，运算如下：
01010100(2)
&00111011(2)
00010000(2)
即：a=84,b=59
c=a&b=16
c语言源代码：
#include <stdio.h>
main()
{
    int a=84;
    int b = 59;
    printf("%d",a&b);
}

2、“按位或”运算符（|）

两个相应的二进制位中只要有一个为1，该位的结果值为1。借用逻辑学中或运算的话来说就是，一真为真
。
例如：60（8）|17（8）,将八进制60与八进制17进行按位或运算。
00110000
|00001111
00111111
c语言源代码：
#include <stdio.h>
main()
{
    int a=060;
    int b = 017;
    printf("%d",a|b);
}
应用：按位或运算常用来对一个数据的某些位定值为1。例如：如果想使一个数a的低4位改为1，则只需要将a与17（8）进行按位或运算即可。
３、按位异或 若参加运算的两个二进制位值相同则为0，否则为1
应用：交换两个值，不用临时变量

例如：ａ＝３，即11（2）；ｂ＝４，即100（2）。
想将ａ和ｂ的值互换，可以用以下赋值语句实现：
ａ＝a∧b; 011 ^ 100 = 111 
ｂ＝b∧a; 100 ^ 111 = 011 = b
ａ＝a∧b; 111 ^ 011 = 100 = a
ａ＝011(2)
（∧）ｂ＝100(2)
ａ＝111(2)（a∧b的结果，a已变成７）
（∧）ｂ＝100(2)
ｂ＝011(2)（b∧a的结果，b已变成３）
（∧）ａ＝111(2)

ａ＝100（2）（a∧b的结果，a已变成４）
等效于以下两步：
① 执行前两个赋值语句：“ａ＝ａ∧ｂ；”和“ｂ＝ｂ∧ａ；”相当于b=b∧(a∧b)。
② 再执行第三个赋值语句： ａ＝ａ∧ｂ。由于a的值等于（ａ∧ｂ），b的值等于（ｂ∧ａ∧ｂ），
因此，相当于a=ａ∧ｂ∧ｂ∧ａ∧ｂ，即a的值等于ａ∧ａ∧ｂ∧ｂ∧ｂ，等于ｂ。
很神奇吧！
c语言源代码：

复制代码 代码如下:

#include <stdio.h>
main()
{
    int a=3;
    int b = 4;
    a=a^b;
    b=b^a;
    a=a^b;
    printf("a=%d b=%d",a,b);
}


4、“取反”运算符（~）

他是一元运算符，用于求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。
例如：~77(8)
源代码：
#include <stdio.h>
main()
{
    int a=077;
    printf("%d",~a);
}

5、左移运算符（<<）
左移运算符是用来将一个数的各二进制位左移若干位，移动的位数由右操作数指定（右操作数必须是非负
值），其右边空出的位用0填补，高位左移溢出则舍弃该高位。
例如：将a的二进制数左移2位，右边空出的位补0，左边溢出的位舍弃。若a=15,即00001111（2），左移2
位得00111100（2）。
源代码：
#include <stdio.h>
main()
{
    int a=15;
    printf("%d",a<<2);
}
左移1位相当于该数乘以2，左移2位相当于该数乘以2*2＝4,15＜＜2=60，即乘了４。但此结论只适用于该
数左移时被溢出舍弃的高位中不包含1的情况。
假设以一个字节（８位）存一个整数，若ａ为无符号整型变量，则ａ＝64时，左移一位时溢出的是0
，而左移2位时，溢出的高位中包含1。

6、右移运算符（>>）
右移运算符是用来将一个数的各二进制位右移若干位，移动的位数由右操作数指定（右操作数必须是非负
值），移到右端的低位被舍弃，对于无符号数，高位补0。对于有符号数，某些机器将对左边空出的部分
用符号位填补（即“算术移位”），而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。注
意：对无符号数,右移时左边高位移入0；对于有符号的值,如果原来符号位为0(该数为正),则左边也是移
入0。如果符号位原来为1(即负数),则左边移入0还是1,要取决于所用的计算机系统。有的系统移入0,有的
系统移入1。移入0的称为“逻辑移位”,即简单移位；移入1的称为“算术移位”。
例： a的值是八进制数113755：
a:1001011111101101 （用二进制形式表示）
a>>1: 0100101111110110 (逻辑右移时)
a>>1: 1100101111110110 (算术右移时)
在有些系统中,a>>1得八进制数045766,而在另一些系统上可能得到的是145766。Turbo C和其他一些C
编译采用的是算术右移,即对有符号数右移时,如果符号位原来为1，左面移入高位的是1。
源代码：
#include <stdio.h>
main()
{
    int a=0113755;
    printf("%d",a>>1);
}

7、位运算赋值运算符
位运算符与赋值运算符可以组成复合赋值运算符。
例如: &=, |=, >>=, <<=, ∧=
例： a & = b相当于 a = a & b
a << =2相当于a = a << 2

c异或运算符：

与运算：&
两者都为1为1，否则为0

1&1=1, 1&0=0, 0&1=0, 0&0=0


或运算：|
两者都为0为0，否则为1
1|1 = 1, 1|0 = 1, 0|1 = 1, 0|0 = 0


非运算：~
1取0，0取1
~1 = 0, ~0 = 1
~(10001) = 01110


异或运算
两者相等为0,不等为1
1^1=0, 1^0=1, 0^1=1, 0^0=0
*/

#import "OperatorViewController.h"

@interface OperatorViewController ()

@end

@implementation OperatorViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    uint8_t *a = "01245789abcdef";
    uint8_t *b = a + 1;
    NSLog(@"a = %s, b = %s", a, b);
    
    NSLog(@"a[0] = %d, b[0] = %d", a[0],b[0]);
    [self sumA:6 B:8 C:5 D:7];
}


- (void)sumA:(int)a B:(int)b C:(int)c D:(int)d
{
    int sum = a + b + c + d;
    NSMutableArray *arr = [NSMutableArray arrayWithArray:@[@(a), @(b), @(c), @(d)]];
    for (int i = 0; i < arr.count; i++) {
        for (int j = i + 1; j < arr.count; j++) {
            int x = [arr[i] intValue];
            int tmp = [arr[j] intValue];
            if (tmp > x) {
                arr[i] = @(tmp);
                arr[j] = @(x);
            }
        }
    }
    
    NSLog(@"%@", arr);
    
    for (int k = 0; k < arr.count; k++) {
        sum = sum + [arr[k] intValue];
    }
}


- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

/*
#pragma mark - Navigation

// In a storyboard-based application, you will often want to do a little preparation before navigation
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
    // Get the new view controller using [segue destinationViewController].
    // Pass the selected object to the new view controller.
}
*/

@end
